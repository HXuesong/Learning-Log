2020年5月14日
by HXuesong



# 算法编程
- 题目要求：
```
你和小军正在上一堂微积分的课。这堂课会持续m分钟，并且在第i分钟之内教授会讲授a_i个公式。

小军虽然对微积分很感兴趣，但是由于他昨晚没有睡好，所以偶尔会打瞌睡。给出一个长度为m的数组t，如果为1，表示小军在第i分钟之内是清醒的；如果为0，表示小军在第i分钟之内是睡着的。当小军是清醒的时候，他会记下这分钟内教授讲授的所有公式；但是他睡着了就是睡着了，什么事情也不会干。

你有一个技巧，可以让小军连续k分钟都保持清醒。但是这个技巧你只能使用一次，你可以在第1到第m-k+1的任意一分钟的开始时刻使用这个技巧。如果你在某一分钟如第i分钟的开始时刻使用了这个技巧，那么小军将会在第j分钟内保持清醒并且记下所有的公式，j满足(i <= j <= i + k - 1)。

你的任务是在合适的时候使用这个技巧，使得小军可以记最多的公式，请你编程帮他计算出最多能记下多少公式。
（程序运行要求，时间：2sec/空间：256MB）

输入
第一行两个整数m和k，含义如题。
第二行m个整数，表示教授每分钟教授的公式的数量。
第三行m个整数，表示小军每分钟的状态，为1是清醒的，为0则睡着了。
满足1 <= k <= m <= 10^5。

输出
一个整数，表示小军记下的最多的公式的数量。

样例
输入
6 3 
2 3 5 2 5 3 
1 1 0 1 0 0
输出
17
```



- 解题思路：
先统计未使用魔法前能记录的公式数，再统计从i到i+k分钟的补充听课记录公式数，统计方法为**双指针**，选最多的与之前的公式数相加即为答案。



- 源代码：
```c++
#include <bits/stdc++.h>

using namespace std;

/*
*param a[]：公式数量
*param vis：小军状态
*param ans：习得公式数
*param sum：以第i项结束的前k项的和
*/

int a[100100];
int vis[100100];
int sum[100100];

int main() {
    
	int i, j;
	int m, k;
	cin >> m >> k;
	
	for(int i = 0; i < m; i++) {
		scanf("%d", a + i);
	}
	for(int i = 0; i < m; i++)
		scanf("%d", vis + i);
		
	int ans = 0;
	
	for(int i = 0; i < m; i++) {
		if(vis[i] == 1)
			ans += a[i];
	}
	
//统计前k个，表示双指针初始的情况
	for(int i = 0; i < k; i++) {
		if(vis[i] == 0)
			sum[k - 1] += a[i];
	}
	
	j = 0;
	
    //统计从i到i+k分钟的补充听课记录公式数，统计方法为双指针
	for(int i = k; i < m; i++, j++) {
		int summ = sum[i - 1];
		if(vis[j] == 0)
			summ -= a[j];
		if(vis[i] == 0)
			summ += a[i];
		sum[i] = summ;
	}
	
	int mm = 0;
	
//选取最大
	for(int i = k - 1; i < m; i++) {
		if(sum[i] > mm)
			mm = sum[i];
	}
	
	cout << ans + mm << endl;
	
	return 0;
}
```